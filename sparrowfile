use Sparky::JobApi;
class Pipeline does Sparky::JobApi::Role {

  has Str $.cpu = tags()<cpu> || "2";
  has Str $.mem = tags()<mem> || "7";
  has Str $.num = tags()<num> || "0";

  method stage-test {

    bash qq:to/HERE/, %( description => "az container create" );
    #set -x 
    az container create -g sparky \\
      --name spk-0{$.num} \\
      --image melezhik/sparky-fastspec:v3 \\
      --cpu {$.cpu} --memory {$.mem} \\
      --secure-environment-variables SPARKY_API_TOKEN={%*ENV<SPARKY_API_TOKEN>} \\
      PARENT_PROJECT={tags()<SPARKY_PROJECT>} \\
      PARENT_JOB_ID={tags()<SPARKY_JOB_ID>} \\
      PARENT_API=http://sparrowhub.io:4000 -o table
    HERE

    bash qq:to/HERE/, %( description => "run sparky job" );
    az container exec -g sparky --name spk-0{$.num} \\
    --exec-command "curl -fs -d '' --retry-delay 10 --retry-connrefused --retry 10 -X POST 127.0.0.1:4000/build/project/fastspec" \\
    -o table
    HERE

    my $j = Sparky::JobApi.new: :mine(True);

    my $s;

    my $i = 0;
    while True {
      $s = $j.get-stash();
      sleep(5);
      last if $s<log>;
      $i++;
      say "wait to job finishes, attmp  #{$i}";
      last if $i >= 10;
    }

    say "remote job log: ", $s<log>;

    bash "az container delete -g sparky --name spk-0{$.num} -y -o table", %(
      description => "delete container";
    );

  }


  method stage-main {

    my @jobs;

    for 1 .. 7 -> $i {

      my $j = self.new-job: :workers<67>;

      $j.queue({
        description => "run az container job #{$i}",
        tags => %(
          stage => "test",
          cpu => $.cpu,
          mem => $.mem,
          num => $i
        ),
        #sparrowdo => %(
        #  no_sudo => True,
        #  bootstrap => False
        #),
      });

      @jobs.push: $j;

    }

    my $s = self.wait-jobs(@jobs); 

    die if $s<FAIL>;

  }

}

Pipeline.new.run;  
