use Sparky::JobApi;
class Pipeline does Sparky::JobApi::Role {

  has Str $.cpu = tags()<cpu> || "2";
  has Str $.mem = tags()<mem> || "7";

  method stage-test {

    bash qq:to/HERE/, %( description => "az container create" );
    #set -x 
    az container create -g sparky \\
      --name spk-01 \\
      --image melezhik/sparky-fastspec:v3 \\
      --cpu {$.cpu} --memory {$.mem} \\
      --secure-environment-variables SPARKY_API_TOKEN={%*ENV<SPARKY_API_TOKEN>} \\
      PARENT_PROJECT={tags()<SPARKY_PROJECT>} \\
      PARENT_JOB_ID={tags()<SPARKY_JOB_ID>} \\
      PARENT_API=http://sparrowhub.io:4000 -o table
    HERE

    bash qq:to/HERE/, %( description => "run sparky job" );
    az container exec -g sparky --name spk-01 \\
    --exec-command "curl -fs -d '' --retry-delay 10 --retry-connrefused --retry 10 -X POST 127.0.0.1:4000/build/project/fastspec" \\
    -o table
    HERE

    my $j = Sparky::JobApi.new: :mine(True);

    my $s;

    my $i = 0;
    while True {
      $s = $j.get-stash();
      sleep(3);
      last if $s<log>;
      $i++;
      say "wait to job finishes, attmp  #{$i}";
      last if $i >= 5;
    }

    say "remote job log: ", $s<log>;

    bash "az container delete -g sparky --name spk-01 -y -o table", %(
      description => "delete container";
    );

  }


  method stage-main {

      my $j = self.new-job;

      $j.queue({
        description => "run az container job",
        tags => %(
          stage => "test",
          cpu => $.cpu,
          mem => $.mem,
        ),
        #sparrowdo => %(
        #  no_sudo => True,
        #  bootstrap => False
        #),
      });


      my $s = self.wait-job($j); 

      die if $s<FAIL>;

  }

}

Pipeline.new.run;  
